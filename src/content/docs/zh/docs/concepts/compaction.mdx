---
title: 压缩 (Compaction)
description: 通过历史摘要管理上下文窗口限制。
sidebar:
  order: 4
---

**压缩 (Compaction)** 是管理 Agent “上下文窗口”（LLM 一次可以读取多少文本的限制）的过程。随着对话的增长，它们最终会超过此限制。OpenClaw 使用压缩来压缩旧历史记录，同时保留关键信息。

## 问题

LLM 有固定的 Token 限制（例如 8k, 32k, 128k tokens）。
*   **历史记录过多** -> API 错误或高成本。
*   **截断历史记录** -> Agent 忘记了刚才说过的话。

## 解决方案：自动压缩

当会话历史达到配置的阈值时，OpenClaw 会自动触发压缩。

### 机制

1.  **触发**：`history_tokens > max_context_tokens * 0.8`（示例）。
2.  **选择**：识别历史记录中最旧的 N 条消息。
3.  **摘要**：
    *   调用辅助 LLM 运行“摘要器 (Summarizer)”提示。
    *   输入：旧消息。
    *   输出：简洁的叙述性摘要（例如，“用户询问了关于 Python 的问题。Agent 提供了一个代码片段。”）。
4.  **替换**：
    *   N 条旧消息从活动上下文中移除。
    *   包含摘要的单个 `SystemMessage` 或 `Memory` 条目被插入到历史记录的开头。

### 配置

您可以在 `config.json` 中调整压缩：

```json5
{
  llm: {
    // 模型的最大 token 数
    max_context: 16000,
    // 何时触发压缩
    compaction_threshold: 0.75 // max_context 的 75%
  }
}
```

## 修剪与摘要 (Pruning vs. Summarizing)

*   **修剪 (Pruning)**：简单地丢弃最旧的消息。
    *   *优点*：免费，快速。
    *   *缺点*：完全丢失旧上下文的数据。
*   **摘要 (Summarizing)** (Compaction)：重写旧消息。
    *   *优点*：保留语义和重要事实。
    *   *缺点*：生成摘要需要花费 Token/时间。

OpenClaw 默认为 **摘要**，以获得连续的对话体验。

## 手动压缩

如果 Agent 感觉“混乱”，您可以通过命令强制进行压缩（或“立即摘要”）：

```bash
# (概念性命令，取决于具体的 agent 实现)
/summarize
```

## 对 RAG 的影响

压缩与 RAG（检索增强生成）相互作用。
*   **活动历史 (Active History)**：即时对话（最后 ~20 条消息）。
*   **摘要 (Summary)**：压缩后的过去。
*   **长期记忆 (Long-term Memory / Vector DB)**：提取并永久存储的特定事实。

压缩弥合了活动历史与长期记忆之间的差距。理想情况下，摘要中的重要事实最终会被移动到长期记忆中。
