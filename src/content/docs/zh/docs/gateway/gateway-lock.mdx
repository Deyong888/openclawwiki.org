---
title: Gateway 锁
description: 使用 WebSocket 监听器绑定的 Gateway 单例守卫。
sidebar:
  label: Gateway 锁
  order: 19
---

# Gateway 锁

最后更新: 2025-12-11

## 为什么

- 确保同一主机上每个基础端口只运行一个 Gateway 实例；额外的 Gateway 必须使用隔离的配置文件和唯一的端口。
- 在崩溃/SIGKILL 后依然存活，不留下陈旧的锁文件。
- 当控制端口已被占用时，快速失败并提供清晰的错误。

## 机制

- Gateway 在启动时立即使用独占 TCP 监听器绑定 WebSocket 监听器 (默认 `ws://127.0.0.1:18789`)。
- 如果绑定失败并出现 `EADDRINUSE`，启动时会抛出 `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")`。
- 操作系统会在任何进程退出时自动释放监听器，包括崩溃和 SIGKILL——不需要单独的锁文件或清理步骤。
- 在关闭时，Gateway 会关闭 WebSocket 服务器和底层 HTTP 服务器以立即释放端口。

## 错误表面

- 如果另一个进程占用了端口，启动时抛出 `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")`。
- 其他绑定失败表现为 `GatewayLockError("failed to bind gateway socket on ws://127.0.0.1:<port>: …")`。

## 操作说明

- 如果端口被 *另一个* 进程占用，错误是一样的；释放端口或使用 `openclaw gateway --port <port>` 选择另一个端口。
- macOS 应用程序在生成 Gateway 之前仍然维护自己的轻量级 PID 守卫；运行时锁由 WebSocket 绑定强制执行。
