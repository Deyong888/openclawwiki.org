---
title: Lobster
description: OpenClaw 的类型化工作流运行时，具有可恢复的批准门控。
sidebar:
  label: Lobster
  order: 44
---

# Lobster

Lobster 是一个工作流 Shell，它允许 OpenClaw 将多步工具序列作为单个确定性操作运行，并具有明确的批准检查点。

## 钩子

您的助手可以构建管理自己的工具。请求一个工作流，30 分钟后您就拥有了一个 CLI 以及作为一次调用运行的管道。Lobster 是缺失的一块：确定性管道、明确的批准和可恢复的状态。

## 为什么

如今，复杂的工作流需要多次往返工具调用。每次调用都会消耗 Token，并且 LLM 必须编排每一步。Lobster 将这种编排移动到一个类型化的运行时中：

- **一次调用而不是多次**：OpenClaw 运行一次 Lobster 工具调用并获得结构化结果。
- **内置批准**：副作用（发送电子邮件、发表评论）会暂停工作流，直到明确批准。
- **可恢复**：暂停的工作流返回一个 Token；批准并恢复而无需重新运行所有内容。

## 为什么是 DSL 而不是普通程序？

Lobster 故意设计得很小。目标不是“一种新语言”，而是一个可预测的、对 AI 友好的管道规范，具有一流的批准和恢复 Token。

- **内置批准/恢复**：普通程序可以提示人类，但如果不自己发明该运行时，它就无法使用持久 Token *暂停和恢复*。
- **确定性 + 可审计性**：管道是数据，因此很容易记录、比较、重放和审查。
- **AI 的受限表面**：微小的语法 + JSON 管道减少了“创造性”代码路径，并使验证变得现实。
- **内置安全策略**：超时、输出上限、沙盒检查和白名单由运行时强制执行，而不是每个脚本。
- **仍然可编程**：每一步都可以调用任何 CLI 或脚本。如果您想要 JS/TS，请从代码生成 `.lobster` 文件。

## 工作原理

OpenClaw 在 **工具模式** 下启动本地 `lobster` CLI，并从 stdout 解析 JSON 信封。
如果管道因批准而暂停，该工具将返回 `resumeToken`，以便您稍后继续。

## 模式：小型 CLI + JSON 管道 + 批准

构建使用 JSON 的微型命令，然后将它们链接成单个 Lobster 调用。（下面的示例命令名称——换成您自己的。）

```bash
inbox list --json
inbox categorize --json
inbox apply --json
```

```json
{
  "action": "run",
  "pipeline": "exec --json --shell 'inbox list --json' | exec --stdin json --shell 'inbox categorize --json' | exec --stdin json --shell 'inbox apply --json' | approve --preview-from-stdin --limit 5 --prompt 'Apply changes?'",
  "timeoutMs": 30000
}
```

如果管道请求批准，请使用 Token 恢复：

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

AI 触发工作流；Lobster 执行步骤。批准门控保持副作用明确且可审计。

示例：将输入项映射到工具调用：

```bash
gog.gmail.search --query 'newer_than:1d' \
  | openclaw.invoke --tool message --action send --each --item-key message --args-json '{"provider":"telegram","to":"..."}'
```

## 仅 JSON LLM 步骤 (llm-task)

对于需要 **结构化 LLM 步骤** 的工作流，启用可选的 `llm-task` 插件工具并从 Lobster 调用它。这保持了工作流的确定性，同时仍允许您使用模型进行分类/总结/起草。

启用工具：

```json
{
  "plugins": {
    "entries": {
      "llm-task": { "enabled": true }
    }
  },
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": { "allow": ["llm-task"] }
      }
    ]
  }
}
```

在管道中使用它：

```lobster
openclaw.invoke --tool llm-task --action json --args-json '{
  "prompt": "Given the input email, return intent and draft.",
  "input": { "subject": "Hello", "body": "Can you help?" },
  "schema": {
    "type": "object",
    "properties": {
      "intent": { "type": "string" },
      "draft": { "type": "string" }
    },
    "required": ["intent", "draft"],
    "additionalProperties": false
  }
}'
```

有关详细信息和配置选项，请参阅 [LLM 任务](/zh/docs/tools/llm-task)。

## 工作流文件 (.lobster)

Lobster 可以运行带有 `name`, `args`, `steps`, `env`, `condition`, 和 `approval` 字段的 YAML/JSON 工作流文件。在 OpenClaw 工具调用中，将 `pipeline` 设置为文件路径。

```yaml
name: inbox-triage
args:
  tag:
    default: "family"
steps:
  - id: collect
    command: inbox list --json
  - id: categorize
    command: inbox categorize --json
    stdin: $collect.stdout
  - id: approve
    command: inbox apply --approve
    stdin: $categorize.stdout
    approval: required
  - id: execute
    command: inbox apply --execute
    stdin: $categorize.stdout
    condition: $approve.approved
```

注意：

- `stdin: $step.stdout` 和 `stdin: $step.json` 传递前一步的输出。
- `condition` (或 `when`) 可以基于 `$step.approved` 门控步骤。

## 安装 Lobster

在运行 OpenClaw 网关的 **同一主机** 上安装 Lobster CLI（参见 [Lobster 仓库](https://github.com/openclaw/lobster)），并确保 `lobster` 在 `PATH` 中。
如果您想使用自定义二进制位置，请在工具调用中传递 **绝对** `lobsterPath`。

## 启用工具

Lobster 是一个 **可选** 插件工具（默认未启用）。

推荐（添加式，安全）：

```json
{
  "tools": {
    "alsoAllow": ["lobster"]
  }
}
```

或每个 Agent：

```json
{
  "agents": {
    "list": [
      {
        "id": "main",
        "tools": {
          "alsoAllow": ["lobster"]
        }
      }
    ]
  }
}
```

避免使用 `tools.allow: ["lobster"]`，除非您打算在限制性白名单模式下运行。

注意：白名单对于可选插件是选择加入的。如果您的白名单仅命名插件工具（如 `lobster`），OpenClaw 将保持核心工具启用。要限制核心工具，请在白名单中也包含您想要的核心工具或组。

## 示例：电子邮件分类

没有 Lobster：
```
User: "Check my email and draft replies"
→ openclaw calls gmail.list
→ LLM summarizes
→ User: "draft replies to #2 and #5"
→ LLM drafts
→ User: "send #2"
→ openclaw calls gmail.send
(repeat daily, no memory of what was triaged)
```

有 Lobster：
```json
{
  "action": "run",
  "pipeline": "email.triage --limit 20",
  "timeoutMs": 30000
}
```

返回一个 JSON 信封（截断）：
```json
{
  "ok": true,
  "status": "needs_approval",
  "output": [{ "summary": "5 need replies, 2 need action" }],
  "requiresApproval": {
    "type": "approval_request",
    "prompt": "Send 2 draft replies?",
    "items": [],
    "resumeToken": "..."
  }
}
```

用户批准 → 恢复：
```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

一个工作流。确定性。安全。

## 工具参数

### `run`

在工具模式下运行管道。

```json
{
  "action": "run",
  "pipeline": "gog.gmail.search --query 'newer_than:1d' | email.triage",
  "cwd": "/path/to/workspace",
  "timeoutMs": 30000,
  "maxStdoutBytes": 512000
}
```

运行带参数的工作流文件：

```json
{
  "action": "run",
  "pipeline": "/path/to/inbox-triage.lobster",
  "argsJson": "{\"tag\":\"family\"}"
}
```

### `resume`

在批准后继续暂停的工作流。

```json
{
  "action": "resume",
  "token": "<resumeToken>",
  "approve": true
}
```

### 可选输入

- `lobsterPath`: Lobster 二进制文件的绝对路径（省略以使用 `PATH`）。
- `cwd`: 管道的工作目录（默认为当前进程工作目录）。
- `timeoutMs`: 如果超出此持续时间则杀死子进程（默认：20000）。
- `maxStdoutBytes`: 如果 stdout 超过此大小则杀死子进程（默认：512000）。
- `argsJson`: 传递给 `lobster run --args-json` 的 JSON 字符串（仅限工作流文件）。

## 输出信封

Lobster 返回带有三种状态之一的 JSON 信封：

- `ok` → 成功完成
- `needs_approval` → 暂停；需要 `requiresApproval.resumeToken` 来恢复
- `cancelled` → 显式拒绝或取消

该工具在 `content`（漂亮的 JSON）和 `details`（原始对象）中都公开信封。

## 批准

如果存在 `requiresApproval`，请检查提示并决定：

- `approve: true` → 恢复并继续副作用
- `approve: false` → 取消并完成工作流

使用 `approve --preview-from-stdin --limit N` 将 JSON 预览附加到批准请求，而无需自定义 jq/heredoc 胶水。恢复 Token 现在很紧凑：Lobster 将工作流恢复状态存储在其状态目录下，并返回一个小 Token 键。

## OpenProse

OpenProse 与 Lobster 搭配使用效果很好：使用 `/prose` 编排多 Agent 准备工作，然后运行 Lobster 管道以获得确定性批准。如果 Prose 程序需要 Lobster，请通过 `tools.subagents.tools` 允许子 Agent 使用 `lobster` 工具。参见 [OpenProse](/zh/docs/prose)。

## 安全

- **仅限本地子进程** — 插件本身没有网络调用。
- **无机密** — Lobster 不管理 OAuth；它调用执行此操作的 OpenClaw 工具。
- **沙盒感知** — 当工具上下文被沙盒化时禁用。
- **强化** — 如果指定 `lobsterPath`，必须是绝对路径；强制执行超时和输出上限。

## 故障排除

- **`lobster subprocess timed out`** → 增加 `timeoutMs`，或拆分长管道。
- **`lobster output exceeded maxStdoutBytes`** → 提高 `maxStdoutBytes` 或减少输出大小。
- **`lobster returned invalid JSON`** → 确保管道在工具模式下运行并仅打印 JSON。
- **`lobster failed (code …)`** → 在终端中运行相同的管道以检查 stderr。

## 了解更多

- [插件](/zh/docs/plugins)
- [插件工具创作](/zh/docs/plugins/agent-tools)

## 案例研究：社区工作流

一个公开示例：“第二大脑” CLI + Lobster 管道，管理三个 Markdown 库（个人、合作伙伴、共享）。CLI 发出 JSON 用于统计、收件箱列表和陈旧扫描；Lobster 将这些命令链接成工作流，如 `weekly-review`, `inbox-triage`, `memory-consolidation`, 和 `shared-task-sync`，每个都有批准门控。AI 在可用时处理判断（分类），在不可用时回退到确定性规则。

- 线程: https://x.com/plattenschieber/status/2014508656335770033
- 仓库: https://github.com/bloomedai/brain-cli
